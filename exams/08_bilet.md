
---

## **Теория 1: Система управления роботом (Robot Control Stack) в терминах ROS. Типовой конвейер**

**Система управления роботом в ROS** — это набор взаимосвязанных программных модулей (нод), организованных в виде вычислительного графа и взаимодействующих через механизм публикации/подписки сообщений. Эта архитектура позволяет разделить функциональность на независимые, переиспользуемые компоненты, что упрощает разработку, отладку и масштабирование робототехнических систем.

### **Типовой конвейер (Navigation Stack):**

**1. Картографирование (Mapping)**
*   **Цель:** Создать карту окружающей среды.
*   **Данные:** Поток данных с лидаров, камер глубины (RGB-D), сонаров.
*   **Процесс:** Сенсорные данные агрегируются и преобразуются в единое представление пространства. В ROS классический подход — использование пакета `gmapping` (алгоритм SLAM на основе частиц), современный — `cartographer`.
*   **Результат:** Чаще всего **Occupancy Grid Map** (2D- или 3D-карта), где каждая ячейка имеет вероятность занятости (значение от 0 до 100).

**2. Локализация (Localization)**
*   **Цель:** Определить положение и ориентацию робота (позу) внутри известной карты в реальном времени.
*   **Данные:** Сенсоры (лидар, одометрия колес, IMU) + готовая карта.
*   **Процесс:** Алгоритм сопоставляет текущие сенсорные данные с картой. Стандартный инструмент в ROS — **Adaptive Monte Carlo Localization (AMCL)**. Это фильтр частиц, который оценивает вероятностное распределение позы робота.
*   **Результат:** Точные координаты `(x, y, theta)` робота в системе координат карты.

**3. Глобальное планирование (Global Planning)**
*   **Цель:** Найти оптимальный (по длине, стоимости) путь от текущего положения робота до заданной целевой точки на карте.
*   **Данные:** Статическая карта, текущая поза (от локализации), целевая поза.
*   **Процесс:** Работает на глобальной карте, игнорируя динамические препятствия. Использует алгоритмы поиска пути на графах:
    *   **A*** — классический эвристический поиск, находит кратчайший путь по стоимости.
    *   **Dijkstra** — частный случай A*.
    *   В ROS (`global_planner`) также могут использоваться варианты: `A*`, `Dijkstra`, `Theta*` (для более прямых путей).
*   **Результат:** Глобальный план — последовательность путевых точек (waypoints) в мировых координатах.

**4. Локальное планирование (Local Planning)**
*   **Цель:** Генерировать траекторию, которой робот может безопасно следовать в реальном времени, объезжая динамические и неучтенные статические препятствия.
*   **Данные:** Глобальный план, карта, поток данных о ближайших препятствиях (от лидара), текущая скорость.
*   **Процесс:** Создает краткосрочные команды движения, учитывая кинематику робота. Ключевой алгоритм в ROS `move_base` — **Dynamic Window Approach (DWA)** или **Timed Elastic Band (TEB)**.
    *   **DWA:** Моделирует возможные будущие траектории в пространстве скоростей (v, ω), оценивает их по критериям (близость к цели, расстояние до препятствий, скорость) и выбирает оптимальную.
*   **Результат:** Команды линейной (`vx`) и угловой (`ωz`) скоростей для контроллера.

**5. Управление двигателями (Motor Control)**
*   **Цель:** Преобразовать команды высокого уровня (скорости) в низкоуровневые сигналы (PWM, ток) для моторов, чтобы точно реализовать желаемое движение.
*   **Данные:** Целевые скорости (`vx`, `ωz`) и данные с энкодеров колес (фактическая скорость).
*   **Процесс:** Использует **ПИД-регулятор (PID controller)**. Он вычисляет ошибку между заданной и фактической скоростями и генерирует корректирующий сигнал для драйверов двигателей.
*   **Результат:** Действия, приводящие робота в движение по запланированной траектории.

---

## **Теория 2: Построение карт с использованием деревьев (Octree в 3D)**

**Проблема:** 3D-окружения огромны и в основном **разрежены** (большая часть пространства пуста). Хранение их в виде плотной 3D-сетки (voxel grid) приводит к чудовищному расходу памяти (O(n³)).

**Решение: Octree (восьмеричное дерево).**
Это иерархическая структура данных, рекурсивно разбивающая пространство на восемь октантов (подкубов).

### **Как это работает для карт:**
1.  **Инициализация:** Весь объем мира — это один большой куб (корневой узел).
2.  **Вставка данных:** Когда лидарный луч указывает, что воксель занят (или свободен), алгоритм рекурсивно спускается по дереву к соответствующему листовому узлу, представляющему этот воксель.
3.  **Адаптивное разрешение:**
    *   Если узел однороден (например, полностью пуст или полностью занят), он остается листовым.
    *   Если в узел попадают данные разной "занятости" или нужна детализация границ, узел **субдивизируется** — разбивается на 8 дочерних узлов.
4.  **Хранение вероятности:** Каждый листовой узел хранит не бинарное значение ("занято/свободно"), а вероятность занятости (например, по алгоритму **OctoMap**). Это позволяет обновлять карту с новыми данными и учитывать неопределенность.

### **Преимущества (эффективность):**
*   **Экономия памяти:** Хранятся только детализированные области (границы объектов, сложная геометрия). Пустые и однородно занятые пространства представляются крупными узлами.
*   **Быстрые операции:** Поиск, вставка и обновление имеют сложность O(log n). Быстрое определение коллизий (столкновений) за счет спуска по дереву.
*   **Масштабируемость:** Можно представлять как маленькие, так и гигантские пространства.
*   **Сжатие без потерь:** Данные не теряются, структура адаптируется под их распределение.
*   **Легкое сжатие до любого разрешения:** Можно "обрезать" дерево на нужной глубине для получения карты с грубым разрешением.

**Вывод:** Octree — это идеальный компромисс между детализацией, объемом памяти и скоростью работы для **3D SLAM** и навигации в больших пространствах.

---

## **Задача: Постобработка пути A* для безопасности и плавности**

**Проблема:** Путь A* является жадным и стремится к вершинам графа, часто "вгрызаясь" в углы препятствий. Это небезопасно (риск столкновения из-за ошибок локализации и контроля) и приводит к резким, энергозатратным поворотам.

### **Предлагаемый метод: Сглаживание пути с помощью алгоритма Gradient Descent Path Smoother**

Это один из самых популярных и эффективных методов постобработки в робототехнике (используется, например, в **nav2**).

**Алгоритм:**
1.  **Вход:** Исходный путь A* как последовательность узлов `P = {p₀, p₁, ..., pₙ}`.
2.  **Целевая функция:** Определяем функцию стоимости `F(p)`, которую будем минимизировать:
    *   **F = α * F_curvature + β * F_distance + γ * F_smoothness**
    *   Где:
        *   **F_curvature (кривизна):** Штраф за резкие повороты. Вычисляется через угол между векторами `(pᵢ - pᵢ₋₁)` и `(pᵢ₊₁ - pᵢ)`. Чем больше угол, тем выше штраф.
        *   **F_distance (расстояние до препятствий):** Обеспечивает безопасность. Для каждой точки `pᵢ` вычисляется минимальное расстояние до ближайшего препятствия на карте (используя **distance transform**). Если расстояние меньше заданного безопасного радиуса `d_safe`, штраф резко возрастает.
        *   **F_smoothness (гладкость):** Штрафует большие расстояния между соседними точками пути, заставляя их выравниваться. Например, `Σ ||pᵢ - 0.5*(pᵢ₋₁ + pᵢ₊₁)||²`.
3.  **Оптимизация:** Применяем метод градиентного спуска (или его вариации, например, **Conjugate Gradient**) к исходному пути `P`.
    *   На каждом шаге итеративно вычисляем градиент целевой функции `∇F` по координатам каждой точки пути (кроме начальной и конечной, которые фиксированы).
    *   Сдвигаем каждую точку пути в направлении, противоположном градиенту: `pᵢ = pᵢ - η * ∇F(pᵢ)`, где `η` — скорость обучения.
    *   Повторяем до схождения (или заданного числа итераций).
4.  **Выход:** Сглаженный путь `P_smooth`, который:
    *   Отодвинут от углов и препятствий.
    *   Имеет более плавные повороты.
    *   Остается в свободном пространстве.

**Преимущества метода:**
*   **Безопасность:** Явно контролируется расстоянием до препятствий.
*   **Плавность:** Путь пригоден для следования роботов с кинематическими ограничениями.
*   **Гибкость:** Веса `α, β, γ` настраиваются под конкретного робота и среду.

**Альтернативы:**
*   **Визуализация пути:** Упрощение пути (алгоритм Рамера-Дугласа-Пекера) с последующей интерполяцией сплайнами (кривыми Безье, B-сплайнами).
*   **Potential Field:** Моделирование пути как упругой ленты, отталкивающейся от препятствий и стягивающейся к прямой.