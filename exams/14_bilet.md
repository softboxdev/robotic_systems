# Разбор билета 14

---

## **Теория 1: Экономические и технические факторы жизненного цикла промышленных роботизированных комплексов на примере карьерного транспорта**

### **Контекст: Автономные карьерные самосвалы**
**Примеры:** Komatsu Autonomous Haulage System (AHS), Caterpillar Command, БелАЗ с автономным управлением

**Жизненный цикл:** 10-15 лет (закупка → эксплуатация → модернизация → утилизация)

---

### **Технические факторы:**

#### **1. Надежность и живучесть:**
- **Экстремальные условия:** Пыль, вибрация, перепады температур (-40°C...+50°C)
- **Техническое обслуживание:**
  - Частота ТО: каждые 250-500 моточасов
  - Замена шин: каждые 5000-8000 часов (стоимость до $50,000 за шину)
  - Калибровка сенсоров: еженедельно/ежемесячно
- **MTBF (Mean Time Between Failures):**
  - Лидары: 10,000-30,000 часов
  - Вычислительные системы: 50,000+ часов
  - Датчики GNSS/RTK: 100,000+ часов

#### **2. Точность и производительность:**
- **Требования к позиционированию:** ±10 см в плане, ±5 см по высоте
- **Скорость движения:** до 40 км/ч с грузом, 60+ без груза
- **Точность выгрузки:** ±30 см к точке разгрузки
- **Производительность:** 200-500 тонн/час на самосвал

#### **3. Безопасность:**
- **Системы резервирования:** Dual/quad-redundant вычислители
- **Emergency Stop:** Срабатывание за < 0.5 сек
- **Защита от кибератак:** Изолированные сети, криптография
- **Fail-operational архитектура:** Продолжение работы при одиночных отказах

#### **4. Интеграция с инфраструктурой:**
- **Картографирование карьера:** Лидарное сканирование 1-2 раза в год
- **Дорожная сеть:** Виртуальные "рельсы" + динамические зоны
- **Центр управления:** 1 оператор на 10-50 машин
- **Системы V2X:** Связь между машинами, с погрузчиками, светофорами

#### **5. Эволюция технологий:**
- **Апгрейд "по воздуху" (OTA):** Обновления ПО без простоя
- **Модульность:** Замена вычислительных модулей без изменения шасси
- **Сенсорная эволюция:** От 2D лидаров к 3D, добавление тепловизоров

---

### **Экономические факторы:**

#### **1. Капитальные затраты (CAPEX):**
- **Закупка оборудования:**
  - Автономный самосвал: $3-5 млн (на 30-40% дороже обычного)
  - Инфраструктура: $1-2 млн (связь, серверы, ЦУ)
  - Лицензионное ПО: $500,000-$1 млн
- **Внедрение:**
  - Обучение персонала: $100,000-$500,000
  - Интеграция с существующими системами: $200,000-$1 млн

#### **2. Операционные расходы (OPEX):**
- **Экономия на персонале:**
  - Водитель: $70,000-$100,000/год × 3 смены = $210,000-$300,000/год
  - Оператор ЦУ: $100,000/год на 10-50 машин
  - **Экономия:** $150,000-$250,000/год на машину
- **Экономия топлива:**
  - Оптимальные траектории: экономия 10-20%
  - Плавное движение: +5-10% к ресурсу двигателя
  - **Пример:** 100 л/час × 6000 часов × $1/л × 15% = $90,000/год
- **Снижение износа:**
  - Шины: +20-30% к ресурсу
  - Тормоза: +30-50% к ресурсу
  - **Экономия:** $50,000-$100,000/год на машину
- **Увеличение производительности:**
  - 24/7 работа без перерывов: +20-30% выработки
  - Оптимальная загрузка: +5-10%
  - **Прирост:** 5000 дополнительных тонн/день × $2/тонна = $3.6 млн/год

#### **3. Общая экономика (TCO - Total Cost of Ownership):**

**За 10 лет на 1 машину:**
```
Обычный самосвал:
- Закупка: $2.5 млн
- Водители (3 смены): $100,000 × 3 × 10 = $3 млн
- Топливо: 6000 ч/год × 100 л/ч × $1 × 10 = $6 млн
- Ремонт/ТО: $500,000/год × 10 = $5 млн
- Шины: $200,000/год × 10 = $2 млн
Итого: ~$18.5 млн

Автономный:
- Закупка: $3.5 млн (+40%)
- Инфраструктура (доля): $500,000
- Операторы (1 на 20 машин): $10,000/год × 10 = $100,000
- Топливо (-15%): $6 млн × 0.85 = $5.1 млн
- Ремонт/ТО (-20%): $5 млн × 0.8 = $4 млн
- Шины (+25% ресурса): $2 млн × 0.75 = $1.5 млн
- ПО/обновления: $100,000/год × 10 = $1 млн
Итого: ~$15.2 млн

Экономия за 10 лет: $3.3 млн на машину
ROI (Return on Investment): 2-3 года
```

#### **4. Риски и их стоимостная оценка:**
- **Простой техники:** $500-$1000/час
- **Авария с повреждением:** $100,000-$1 млн
- **Кибератака:** Убытки + репутационные потери
- **Технологическое устаревание:** Амортизация за 5-7 лет

#### **5. Макроэкономические факторы:**
- **Цены на полезные ископаемые:** При высокой цене - быстрый ROI
- **Регуляторная среда:** Требования к безопасности, страхованию
- **Рынок труда:** Дефицит водителей → ускорение автоматизации
- **Экологические нормы:** Требования к выбросам → оптимизация маршрутов

---

### **Факторы, влияющие на принятие решений:**

#### **На этапе закупки:**
1. **Техническая оценка:** Совместимость с существующей техникой
2. **Финансирование:** Лизинг vs покупка
3. **Поставщик:** Гарантии, сервис, обучение
4. **Масштабируемость:** От 1 машины до всего парка

#### **На этапе эксплуатации:**
1. **Мониторинг эффективности:** KPI (тонны/час, стоимость/тонна)
2. **Прогнозное обслуживание:** Датчики вибрации, температуры
3. **Адаптация к изменениям:** Новые участки карьера, изменение маршрутов

#### **На этапе модернизации:**
1. **Апгрейд vs замена:** Что экономически выгоднее?
2. **Интеграция новых технологий:** AI для оптимизации, новые сенсоры
3. **Утилизация:** Перепродажа, разбор на запчасти, рециклинг

---

### **Тренды и будущее:**

#### **Технические:**
- **Роевое поведение:** Координация десятков машин без центрального управления
- **Беспилотные конвои:** Лидер-ведомые для экономии топлива
- **Электрификация:** Автономные электромобили + беспроводная зарядка
- **Цифровые двойники:** Виртуальное тестирование изменений

#### **Экономические:**
- **RaaS (Robotics as a Service):** Аренда автономных систем, а не покупка
- **Платформенные решения:** Единая ОС для разных типов техники
- **Данные как актив:** Продажа аналитики по эффективности карьера

---

## **Теория 2: Топологические карты для семантической навигации в крупномасштабных средах**

### **Проблема метрических карт для больших пространств:**
- **Разрешение 5 см:** Здание 100×100 м = 2000×2000 = 4 млн ячеек
- **Многоэтажное здание:** 10 этажей × 4 млн = 40 млн ячеек
- **Планирование пути:** O(n²) для сеточных представлений
- **Семантическая бедность:** Карта знает "занято/свободно", но не "комната 301", "лифт А"

---

### **Топологическая карта:**
**Идея:** Представить пространство как **граф значимых мест и связей**

**Вершины графа = семантические локации:**
- Комнаты, коридоры, лестницы, лифты, входы/выходы
- Каждая вершина имеет:
  - Идентификатор: "комната_301", "коридор_3_й_этаж"
  - Тип: ROOM, CORRIDOR, ELEVATOR, STAIRS
  - Метрическую привязку: Центроид или область (полигон)
  - Атрибуты: Доступность (для инвалидов), назначение, владелец

**Ребра графа = навигационные связи:**
- Типы: DOOR, CORRIDOR_SEGMENT, STAIRWAY, ELEVATOR_SHAFT
- Вес: Расстояние, время прохода, энергозатраты, сложность
- Ограничения: Ширина прохода, высота, требования доступа

---

### **Алгоритм построения топологической карты:**

#### **Этап 1: Метрическое картографирование (SLAM)**
```python
# Получаем обычную occupancy grid map
grid_map = gmapping.build_map(laser_scans, odometry)
# Разрешение 5-10 см для детализации
```

#### **Этап 2: Сегментация на помещения**
```python
def segment_rooms(grid_map):
    # 1. Определение свободного пространства
    free_cells = extract_free_space(grid_map)
    
    # 2. Выделение connected components
    rooms = connected_components(free_cells)
    
    # 3. Удаление коридоров (узких областей)
    for room in rooms:
        if is_corridor(room, width_threshold=2.0):
            room.type = CORRIDOR
        else:
            room.type = ROOM
    
    # 4. Слияние слишком маленьких комнат
    merge_small_rooms(rooms, min_area=5.0)
    
    return rooms
```

#### **Этап 3: Выделение узлов графа**
```python
def extract_topological_nodes(rooms, grid_map):
    nodes = []
    
    # 1. Для каждой комнаты - центроид
    for room in rooms:
        if room.type == ROOM:
            centroid = calculate_centroid(room.contour)
            node = TopologicalNode(
                id=f"room_{len(nodes)}",
                type=ROOM,
                position=centroid,
                polygon=room.contour
            )
            nodes.append(node)
    
    # 2. Дверные проемы
    doorways = detect_doorways(grid_map, rooms)
    for doorway in doorways:
        node = TopologicalNode(
            id=f"door_{len(nodes)}",
            type=DOORWAY,
            position=doorway.center,
            width=doorway.width
        )
        nodes.append(node)
    
    # 3. Особые места (лестницы, лифты)
    special_places = detect_special_places(grid_map, semantic_data)
    # ... добавляем
    
    return nodes
```

#### **Этап 4: Построение ребер (связей)**
```python
def build_topological_edges(nodes, grid_map):
    edges = []
    
    # 1. Связи через дверные проемы
    for doorway in filter(lambda n: n.type == DOORWAY, nodes):
        # Найти комнаты, которые соединяет эта дверь
        connected_rooms = find_connected_rooms(doorway, nodes)
        
        for room1, room2 in combinations(connected_rooms, 2):
            edge = TopologicalEdge(
                from_node=room1.id,
                to_node=room2.id,
                type=DOOR_CONNECTION,
                weight=calculate_distance(room1, room2, through=doorway),
                constraint={"must_pass": doorway.id}
            )
            edges.append(edge)
    
    # 2. Связи внутри коридоров
    corridors = filter(lambda n: n.type == CORRIDOR, nodes)
    for corridor in corridors:
        # Связать все комнаты, выходящие в этот коридор
        adjacent_rooms = find_adjacent_rooms(corridor, nodes)
        
        # Полносвязный граф между комнатами через коридор
        for room1, room2 in combinations(adjacent_rooms, 2):
            edge = TopologicalEdge(
                from_node=room1.id,
                to_node=room2.id,
                type=CORRIDOR_CONNECTION,
                weight=corridor_distance(room1, room2, corridor),
                constraint={"corridor_id": corridor.id}
            )
            edges.append(edge)
    
    # 3. Межэтажные связи (лестницы, лифты)
    # ... строим связи между узлами на разных этажах
    
    return edges
```

#### **Этап 5: Обогащение семантикой**
```python
def add_semantic_information(topological_graph, building_data):
    # 1. Добавить информацию из BIM (Building Information Model)
    for node in topological_graph.nodes:
        if node.type == ROOM:
            # Найти соответствующую комнату в BIM
            bim_room = find_in_bim(node.position, building_data)
            if bim_room:
                node.attributes.update({
                    "room_number": bim_room.number,
                    "purpose": bim_room.purpose,
                    "department": bim_room.department,
                    "capacity": bim_room.capacity,
                    "access_level": bim_room.access_level
                })
    
    # 2. Добавить динамическую информацию
    for edge in topological_graph.edges:
        # Исторические данные о трафике
        edge.attributes["avg_traffic"] = get_historical_traffic(edge)
        edge.attributes["congestion_level"] = estimate_congestion(edge)
        
        # Временные ограничения
        edge.attributes["time_constraints"] = get_time_constraints(edge)
    
    return topological_graph
```

---

### **Пример топологической карты офисного здания:**
```
Узлы:
- entrance_main (тип: ENTRANCE)
- reception (тип: ROOM, атрибуты: {purpose: "Reception", access: "public"})
- corridor_floor_1 (тип: CORRIDOR)
- room_101 (тип: ROOM, атрибуты: {purpose: "Meeting", capacity: 10})
- room_102 (тип: ROOM, атрибуты: {purpose: "Office", owner: "John Doe"})
- elevator_a (тип: ELEVATOR)
- stairs_main (тип: STAIRS)
- kitchen_floor_1 (тип: FACILITY)

Ребра:
- entrance_main --(DOOR)--> reception
- reception --(CORRIDOR)--> corridor_floor_1
- corridor_floor_1 --(DOOR)--> room_101 (вес: 15м, ограничения: {width: 1.2м})
- corridor_floor_1 --(DOOR)--> room_102
- corridor_floor_1 --(DOOR)--> kitchen_floor_1
- corridor_floor_1 --(ELEVATOR)--> elevator_a
- corridor_floor_1 --(STAIRS)--> stairs_main
```

---

### **Преимущества для планирования в крупномасштабных средах:**

#### **1. Эффективность вычислений:**
- **Обычная сетка:** 40 млн ячеек → поиск пути O(n²)
- **Топологическая:** 100-1000 узлов → поиск пути O(V+E)
- **Пример:** Путь через 5-этажное здание:
  - Метрический планировщик: 100-1000 мс
  - Топологический: 1-10 мс

#### **2. Семантическое планирование:**
```python
# Запрос: "Доставка в комнату 301 Джону Доу"
def semantic_planning(query):
    # 1. Поиск целевой комнаты по семантике
    target_room = find_room_by_attribute(
        graph, 
        {"room_number": "301", "owner": "John Doe"}
    )
    
    # 2. Поиск текущего положения робота
    current_node = localize_in_topological_map(current_pose, graph)
    
    # 3. Поиск пути в графе
    path = dijkstra(graph, current_node, target_room)
    
    # 4. Преобразование в метрический путь
    metric_path = []
    for edge in path.edges:
        # Для каждого ребра получаем метрическую траекторию
        segment = get_metric_path_for_edge(edge)
        metric_path.extend(segment)
    
    return metric_path
```

#### **3. Многоуровневое планирование:**
```
Уровень 1: Стратегический (топологический)
  "Из вестибюля в комнату 301 через лифт А"

Уровень 2: Тактический (метрический внутри узла)
  "От двери комнаты 301 до стола"

Уровень 3: Реактивный (локальное избегание)
  "Обойти человека в коридоре"
```

#### **4. Легкость обновления:**
- **Изменения в здании:** Перестройка комнаты → обновить 1 узел, а не миллионы ячеек
- **Временные изменения:** Закрытие коридора → удалить ребро
- **Динамическая информация:** Перегрузка лифта → увеличить вес ребра

#### **5. Естественность для человека:**
- **Команды:** "Иди в кафетерий на 3 этаже", а не "x=125.3, y=87.2, θ=1.57"
- **Отчеты:** "Робот в коридоре около лифта", а не "x=... y=..."
- **Инструкции:** "Поверни налево у кухни, потом прямо до конца коридора"

---

### **Интеграция с ROS:**

#### **Пакеты для топологической навигации:**
```bash
# topological_navigation (из Strands проекта)
roslaunch topological_navigation topological_navigation.launch

# или custom реализация
```

#### **Сообщения ROS:**
```python
# topological_map.msg
Header header
TopologicalNode[] nodes
TopologicalEdge[] edges

# TopologicalNode.msg
string id
string type  # ROOM, CORRIDOR, DOOR, ELEVATOR, etc.
geometry_msgs/Pose pose
string[] properties  # room_number=301, purpose=office
float32[] polygon_x  # Контур помещения
float32[] polygon_y

# TopologicalEdge.msg
string id
string from_node
string to_node
string type  # DOOR_CONNECTION, CORRIDOR_CONNECTION
float32 weight  # Расстояние/время
string[] constraints  # width>1.0, access_level>=2
```

#### **Навигационный стек с топологией:**
```xml
<!-- Гибридная архитектура -->
<node pkg="topological_planner" type="topological_planner" name="topological_planner">
  <remap from="goal" to="/topological_goal"/>
  <param name="map_file" value="$(find my_robot)/maps/building_topological.yaml"/>
</node>

<node pkg="move_base" type="move_base" name="move_base">
  <!-- Используем локальный планировщик для исполнения сегментов -->
</node>

<!-- Связующий узел -->
<node pkg="hybrid_navigation" type="hybrid_bridge" name="hybrid_bridge">
  <remap from="topological_path" to="/topological_planner/path"/>
  <remap from="metric_goals" to="/move_base_simple/goal"/>
</node>
```

---

### **Пример использования в больнице:**

**Задача:** Доставка медикаментов из аптеки в палату 512

**Топологический план:**
1. Аптека (1 этаж) → коридор_1 → лифт_B
2. Лифт_B: 1 этаж → 5 этаж
3. Коридор_5 → палата_512

**Преимущества:**
- Избегает перегруженных коридоров в часы пик
- Использует лифты с разрешением для роботов
- Учитывает время: ночью использует служебные лифты
- При недоступности лифта B автоматически выбирает запасной маршрут через лифт C

---

## **Задача: Анализ сценария расхождения global_planner и DWA local planner**

### **Сценарий:**
```
Глобальный планировщик: ✓ Нашел путь
Локальный планировщик (DWA): ✗ Не может выполнить, робот останавливается
```

### **Диагностическое дерево:**

```
Проблема: DWA не исполняет глобальный план
├── 1. Проблемы с входными данными DWA
│   ├── 1.1. Неверная текущая поза робота
│   ├── 1.2. Глобальный план в неправильной системе координат
│   └── 1.3. Costmap показывает препятствия на пути
├── 2. Параметры DWA слишком консервативные
│   ├── 2.1. Слишком большие размеры робота
│   ├── 2.2. Слишком большой inflation_radius
│   └── 2.3. Высокие штрафы за препятствия
├── 3. Кинематические ограничения
│   ├── 3.1. Макс. скорость слишком низкая
│   ├── 3.2. Минимальный радиус поворота не позволяет маневр
│   └── 3.3. Путь требует движения назад, но min_vel_x ≥ 0
├── 4. Проблемы с оценкой траекторий
│   ├── 4.1. Sim_time слишком короткий
│   ├── 4.2. Недостаточно samples для поиска
│   └── 4.3. Веса (biases) смещены в сторону осторожности
└── 5. Взаимодействие с recovery behaviors
    ├── 5.1. Робот в recovery mode (clear_costmap, rotate)
    └── 5.2. Проблемы с oscillation detection
```

---

### **Подробный анализ каждой причины:**

#### **Причина 1: Проблемы с входными данными**

**1.1. Неверная текущая поза робота:**
```bash
# Диагностика:
rostopic echo /amcl_pose  # или /odom
rosrun tf tf_echo map base_link

# Если поза неверна:
# 1. Переинициализировать локализацию (в RViz: 2D Pose Estimate)
# 2. Проверить TF дерево
```

**1.2. Глобальный план в неправильной системе координат:**
```bash
# Проверить фрейм плана:
rostopic echo /move_base/GlobalPlanner/plan/header/frame_id
# Должно быть "map"

# Проверить трансформ:
rosrun tf tf_echo map odom
# Должен существовать (публикуется AMCL или odometry)
```

**1.3. Costmap показывает препятствия на пути:**
```bash
# Визуализировать costmap в RViz
# Добавить: Map -> Topic: /move_base/global_costmap/costmap
# Или локальный: /move_base/local_costmap/costmap

# Проверить, нет ли препятствий на пути:
# 1. Лидарные данные корректны? rostopic echo /scan
# 2. Статическая карта корректна? rosservice call /static_map
# 3. Динамические препятствия на пути?
```

#### **Причина 2: Параметры DWA слишком консервативные**

**Критические параметры в dwa_local_planner_params.yaml:**
```yaml
# 2.1. Размеры робота (должны совпадать с costmap_common_params!)
footprint: [[-0.3,-0.25], [-0.3,0.25], [0.3,0.25], [0.3,-0.25]]
# ИЛИ
robot_radius: 0.4

# 2.2. Расстояния до препятствий
inflation_radius: 0.55  # Должно быть > robot_radius + margin
cost_scaling_factor: 10.0  # Меньше = мягче штрафы
inflation_decay_distance: 0.58

# 2.3. Штрафы в DWA
path_distance_bias: 32.0    # Вес следования пути
goal_distance_bias: 20.0    # Вес движения к цели
occdist_scale: 0.01         # Вес избегания препятствий
# Уменьшить occdist_scale или увеличить path_distance_bias
```

**Диагностика:**
```bash
# Посмотреть, какие траектории DWA оценивает:
rostopic echo /move_base/DWAPlannerROS/trajectories  # если включена визуализация

# В RViz: добавить display "Path" -> Topic: /move_base/DWAPlannerROS/local_plan
# И "Marker" -> Topic: /move_base/DWAPlannerROS/trajectories
```

**Решение:** Увеличить "агрессивность" робота:
```yaml
# Уменьшить штрафы за препятствия
occdist_scale: 0.005  # было 0.01

# Увеличить вес следования пути
path_distance_bias: 64.0  # было 32.0

# Уменьшить радиус инфляции (с осторожностью!)
inflation_radius: 0.45  # было 0.55
```

#### **Причина 3: Кинематические ограничения**

**Параметры в local_planner_params.yaml:**
```yaml
# 3.1. Ограничения скоростей
max_vel_x: 0.5      # Макс. скорость вперед
min_vel_x: -0.1     # Мин. скорость (отрицательная для движения назад!)
max_vel_theta: 1.0  # Макс. угловая скорость

# 3.2. Ускорения
acc_lim_x: 0.5      # Линейное ускорение
acc_lim_theta: 1.0  # Угловое ускорение

# 3.3. Для вращения на месте
yaw_goal_tolerance: 0.1  # Допуск по ориентации (рад)
xy_goal_tolerance: 0.1   # Допуск по позиции (м)

# 3.4. Особые настройки
holonomic_robot: false    # true только для голономных роботов
```

**Проблема: Путь требует движения назад:**
```bash
# Проверить, требует ли путь движения назад:
# В RViz смотреть глобальный план
# Если первые точки плана позади робота, а min_vel_x ≥ 0

# Решение: Разрешить движение назад
min_vel_x: -0.2  # Отрицательное значение
```

**Проблема: Слишком крутой поворот:**
```python
# Минимальный радиус поворота вычисляется как:
min_turning_radius = max_vel_x / max_vel_theta
# Пример: 0.5 / 1.0 = 0.5 м

# Если путь требует меньшего радиуса:
# 1. Увеличить max_vel_theta (если механически возможно)
# 2. Разрешить движение на месте (включить вращение на месте)
```

**Диагностика кинематики:**
```bash
# Проверить, генерирует ли DWA траектории
rostopic echo /move_base/DWAPlannerROS/local_plan

# Если local_plan пустой или очень короткий:
# DWA не находит допустимых траекторий
```

#### **Причина 4: Проблемы с оценкой траекторий**

**Параметры симуляции DWA:**
```yaml
# 4.1. Время симуляции траекторий
sim_time: 1.5  # Секунды
# Если слишком мало: DWA не "видит" далеко
# Если слишком много: вычислительно дорого

# 4.2. Количество пробных траекторий
vx_samples: 6         # Линейные скорости
vtheta_samples: 20    # Угловые скорости
# Увеличить для более тщательного поиска

# 4.3. Точность симуляции
sim_granularity: 0.025  # Шаг симуляции (сек)
angular_sim_granularity: 0.025

# 4.4. Окно планирования
controller_frequency: 5.0  # Частота работы DWA (Гц)
```

**Диагностика:**
```bash
# Включить отладочную визуализацию DWA:
rosparam set /move_base/DWAPlannerROS/publish_trajectories true
rosparam set /move_base/DWAPlannerROS/publish_cost_grid_pc true

# В RViz увидеть:
# - Пробные траектории (разноцветные линии)
# - Лучшая траектория (зеленая)
# - Cost grid (точки с цветом по стоимости)
```

**Решение:**
```yaml
# Увеличить горизонт планирования
sim_time: 2.0  # было 1.5

# Увеличить количество пробных траекторий
vx_samples: 10    # было 6
vtheta_samples: 30  # было 20

# Увеличить частоту контроллера
controller_frequency: 10.0  # было 5.0 (в move_base params)
```

#### **Причина 5: Взаимодействие с recovery behaviors**

**DWA может быть "заблокирован" recovery behaviors:**
```bash
# Проверить статус recovery:
rostopic echo /move_base/recovery_status

# Посмотреть, какие recovery behaviors активны:
rosparam get /move_base/recovery_behavior_enabled
rosparam get /move_base/clearing_rotation_allowed
rosparam get /move_base/conservative_reset_dist
```

**Типичная последовательность при застревании:**
1. DWA не находит траекторий
2. Активируется `clearing_rotation_allowed` (робот вращается на месте)
3. Если не помогает → `aggressive_reset_dist` (очистка costmap)
4. Если все еще не помогает → цель отменяется (ABORTED)

**Решение:**
```yaml
# В move_base_params.yaml или local_planner_params.yaml:

# Настроить recovery behaviors:
recovery_behavior_enabled: true
clearing_rotation_allowed: true
conservative_reset_dist: 3.0  # Очищать costmap на 3 м при застревании
aggressive_reset_dist: 1.0    # Очищать на 1 м

# Или временно отключить для диагностики:
recovery_behavior_enabled: false
```

---

### **Пошаговый алгоритм диагностики:**

#### **Шаг 1: Быстрые проверки (1 минута)**
```bash
# 1. Проверить топики
rostopic list | grep -E "(move_base|cmd_vel|scan|odom)"

# 2. Проверить публикует ли DWA команды
rostopic hz /cmd_vel

# 3. Проверить статус move_base
rostopic echo -n 1 /move_base/status

# 4. Проверить TF
rosrun tf tf_echo map base_link
```

#### **Шаг 2: Визуальная диагностика в RViz (2 минуты)**
1. **Добавить displays:**
   - Map: topic=/map
   - Path (глобальный): topic=/move_base/GlobalPlanner/plan
   - Path (локальный): topic=/move_base/DWAPlannerROS/local_plan
   - Costmap: topic=/move_base/local_costmap/costmap
   - TF

2. **Наблюдать:**
   - Глобальный план отображается? (синяя линия)
   - Локальный план отображается? (зеленая линия)
   - Costmap показывает препятствия на пути?
   - Робот в правильном месте относительно карты?

#### **Шаг 3: Глубокая диагностика DWA (3 минуты)**
```bash
# 1. Включить отладку DWA
rosparam set /move_base/DWAPlannerROS/publish_trajectories true
rosparam set /move_base/DWAPlannerROS/publish_cost_grid_pc true

# 2. Перезапустить move_base (чтобы применить параметры)
rosnode kill /move_base
# ... и запустить заново

# 3. В RViz добавить Marker для траекторий
```

#### **Шаг 4: Анализ логов (2 минуты)**
```bash
# Смотреть логи DWA планировщика
rostopic echo /rosout | grep -i "dwa\|planner"

# Или в отдельном терминале:
rosrun rqt_console rqt_console
# Фильтр: "DWAPlannerROS"
```

---

### **Типичные сценарии и решения:**

#### **Сценарий 1: "Робот приближается к цели, затем останавливается"**
**Причина:** Достиг `xy_goal_tolerance`, но ориентация не совпадает
**Решение:**
```yaml
# Увеличить допуски или разрешить достижение цели с любой ориентацией
xy_goal_tolerance: 0.3
yaw_goal_tolerance: 3.14  # π, любая ориентация
latch_xy_goal_tolerance: true
```

#### **Сценарий 2: "Робот не начинает движение от старта"**
**Причина:** Глобальный план начинается "позади" робота, а `min_vel_x ≥ 0`
**Решение:**
```yaml
# Разрешить движение назад
min_vel_x: -0.2

# ИЛИ настроить глобального планировщика на создание плана "вперед"
# В global_planner_params.yaml:
use_dijkstra: false  # A* создает более прямые пути
use_grid_path: false # Использовать gradient path
```

#### **Сценарий 3: "Робот движется, затем останавливается перед узким проходом"**
**Причина:** `inflation_radius` слишком большой или `footprint` неверный
**Решение:**
```bash
# 1. Проверить реальные размеры робота
# 2. Уменьшить inflation_radius (но не меньше robot_radius!)
# 3. Проверить footprint: возможно, робот прямоугольный, а задан как круглый
```

#### **Сценарий 4: "Робот осциллирует, затем останавливается"**
**Причина:** `oscillation_reset_dist` слишком маленький или detection слишком чувствительный
**Решение:**
```yaml
# В DWA params:
oscillation_reset_dist: 0.1  # Увеличить (было 0.05)
oscillation_reset_time: 5.0  # Увеличить время сброса (было 2.0)

# Или отключить oscillation detection (не рекомендуется)
# oscillation_reset_dist: 0.0
```

---

### **Универсальное решение для тестирования:**

**Создать тестовый конфиг DWA:**
```yaml
# test_dwa_params.yaml
DWAPlannerROS:
  # Агрессивные настройки для диагностики
  max_vel_x: 0.3          # Ограничить скорость для безопасности
  min_vel_x: -0.3         # Разрешить движение назад
  max_vel_theta: 0.5      # Ограничить вращение
  
  # Увеличить горизонт планирования
  sim_time: 2.5
  vx_samples: 12
  vtheta_samples: 40
  
  # Уменьшить штрафы за препятствия
  occdist_scale: 0.001    # Очень маленький
  path_distance_bias: 100.0  # Сильно следовать пути
  goal_distance_bias: 50.0   # Двигаться к цели
  
  # Увеличить допуски
  xy_goal_tolerance: 0.5
  yaw_goal_tolerance: 1.57  # 90 градусов
  
  # Отключить recovery для чистоты эксперимента
  recovery_behavior_enabled: false
```

**Загрузить тестовый конфиг:**
```bash
rosparam load test_dwa_params.yaml /move_base
```

---

### **Профилактические меры:**

1. **Согласование параметров:**
   - `robot_radius` в `costmap_common_params.yaml` == `robot_radius` в DWA
   - `footprint` везде одинаковый

2. **Постепенная настройка:**
   - Начинать с больших `tolerance` и маленьких `velocities`
   - Постепенно увеличивать скорость, уменьшать допуски

3. **Мониторинг:**
   ```bash
   # Скрипт для мониторинга состояния DWA
   while true; do
     echo "=== DWA Status ==="
     rostopic echo -n 1 /move_base/status | grep status
     rostopic echo -n 1 /cmd_vel | grep "linear\|angular"
     echo "---"
     sleep 1
   done
   ```

4. **Визуализация всегда включена** в отладочной сборке

**Заключение:** Расхождение между global_planner и DWA обычно вызвано **чрезмерно консервативными параметрами безопасности** или **некорректными кинематическими ограничениями**. Методичная диагностика через визуализацию и постепенная настройка параметров решают 95% таких проблем.