# Разбор билета 11

---

## **Теория 1: Стандарты и протоколы взаимодействия в робототехнических комплексах (на примере ROS)**

**Стандартизация в ROS** — это фундаментальный принцип, обеспечивающий совместимость между различными компонентами робототехнических систем, разработанными разными командами и для разного оборудования.

### **Ключевые стандарты и протоколы в ROS:**

1. **Транспортный уровень (Middleware):**
   - **DDS (Data Distribution Service)** в ROS 2 или TCPROS/UDPROS в ROS 1
   - Обеспечивает надежную доставку сообщений между нодами
   - Поддерживает discovery-механизм (автоматическое обнаружение участников)

2. **Архитектурные паттерны:**
   - **Публикация/Подписка (Publish/Subscribe)** — для потоковых данных (датчики, команды)
   - **Сервисы (Services)** — для синхронных запросов-ответов (запрос состояния, вычисление)
   - **Действия (Actions)** — для длительных асинхронных операций с обратной связью (навигация, захват объекта)

3. **Стандартные типы сообщений (message types):**

### **Почему важна стандартизация сообщений?**

**std_msgs (стандартные сообщения):**
```yaml
# Примеры:
Bool, Int32, Float64, String, Time, Duration
```
**Важность:** 
- **Базовая совместимость:** Позволяют обмениваться простейшими данными между любыми нодами
- **Минимальные накладные расходы:** Легковесные сообщения для простых сигналов
- **Универсальность:** Понимаются всеми компонентами системы

**geometry_msgs (геометрические сообщения):**
```yaml
# Примеры:
Point, Pose, Twist, Vector3, Quaternion, Transform
```
**Важность:**
- **Единое представление пространства:** Все компоненты понимают координаты и ориентацию одинаково
- **Совместимость с TF2:** Система преобразований координат полагается на эти типы
- **Межъязыковая совместимость:** С++ и Python ноды могут обмениваться геометрическими данными
- **Пример использования:** `Twist` сообщение для команд скорости используется всеми драйверами мобильных роботов

**sensor_msgs (сообщения от датчиков):**
```yaml
# Примеры:
LaserScan, Image, PointCloud2, Imu, NavSatFix
```
**Важность:**
- **Аппаратная независимость:** Производители датчиков предоставляют драйверы, выдающие эти стандартные форматы
- **Повторное использование алгоритмов:** Алгоритм обработки изображений работает с любым `Image`, независимо от камеры
- **Стандартизованная мета-информация:** Заголовок с временными метками, система координат, параметры калибровки
- **Эффективность:** Бинарные форматы (например, PointCloud2) оптимизированы для больших объемов данных

### **Преимущества стандартизации:**

1. **Interoperability (совместимость):**
   - Драйвер камеры от компании A + алгоритм компьютерного зрения от компании B + контроллер от компании C
   - "Plug-and-play" компоненты

2. **Повторное использование кода:**
   - Библиотеки обработки (PCL для облаков точек, OpenCV для изображений) ожидают стандартные форматы
   - Разработчики могут сосредоточиться на алгоритмах, а не на парсинге данных

3. **Упрощение отладки и анализа:**
   - Стандартные инструменты визуализации (RViz) понимают все типы сообщений
   - Утилиты записи/воспроизведения (rosbag) работают с любыми данными

4. **Сообщество и экосистема:**
   - Единый "язык" для обмена решениями
   - Возможность создавать универсальные инструменты и утилиты

**Вывод:** Без стандартизации сообщений ROS превратился бы в набор изолированных компонентов, а не в единую экосистему. Стандарты — это "клей", связывающий разнородные компоненты в работающую систему.

---

## **Теория 2: Вероятностная карта занятости (Occupancy Grid Map)**

**Occupancy Grid Map** — это дискретное представление пространства, где каждая ячейка (воксель в 3D) содержит **вероятность того, что эта ячейка занята препятствием**.

### **Основные характеристики:**

1. **Дискретизация:** Пространство разбивается на ячейки фиксированного размера (например, 5×5 см в 2D)
2. **Вероятностное представление:** Значение в ячейке — `p(m_i | z_{1:t})` — вероятность занятости ячейки `i` при всех наблюдениях `z` с момента 1 до `t`
3. **Байесовский подход:** Карта строится инкрементально по мере получения новых данных

### **Процесс обновления карты на основе данных лидара/сонара:**

#### **1. Модель датчика:**
Для каждого луча лидара/сонара определяем:
- **Область занятости (hit):** Ячейка, где луч встретил препятствие (высокая вероятность занятости)
- **Область свободы (free):** Ячейки по лучу до препятствия (низкая вероятность занятости)
- **Область неизвестности (unknown):** Ячейки за препятствием или вне диапазона датчика

#### **2. Логарифмическое представление odds (коэффициентов):**
Вместо работы с вероятностями `p` используют **лог-odds** для численной стабильности:
```
l(m_i) = log( p(m_i) / (1 - p(m_i)) )
```
где:
- `p(m_i)` — вероятность занятости ячейки
- `l(m_i)` — лог-odds

#### **3. Формула обновления (обратный сенсорный модель):**
При получении нового измерения `z_t`:
```
l(m_i | z_{1:t}) = l(m_i | z_{1:t-1}) + l(m_i | z_t) - l(m_i_prior)
```
где:
- `l(m_i | z_{1:t-1})` — предыдущее значение (априорное)
- `l(m_i | z_t)` — лог-odds от текущего измерения
- `l(m_i_prior)` — априорное значение (обычно 0 для неопределенности)

#### **4. Процесс обработки одного скана лидара:**
```
for each луч в скане лидара:
    препятствие_точка = точка_где_луч_ударил_в_объект
    
    # Обновляем ячейку с препятствием (hit)
    для ячейки, содержащей препятствие_точку:
        l += l_occ  # (положительное значение, например, 0.7)
    
    # Обновляем свободные ячейки по лучу до препятствия
    для каждой ячейки вдоль луча от робота до препятствия:
        l += l_free # (отрицательное значение, например, -0.4)
    
    # Ячейки за препятствием не обновляем (остаются неизвестными)
```

#### **5. Преобразование обратно в вероятность:**
```
p(m_i) = 1 - 1 / (1 + exp(l(m_i)))
```
Это дает значение от 0 (точно свободно) до 1 (точно занято), обычно с порогом 0.5 для бинаризации.

### **Преимущества вероятностного подхода:**

1. **Учет неопределенности:** Интегрирует информацию с шумом и ошибками
2. **Инкрементальность:** Можно обновлять в реальном времени
3. **Устойчивость к ошибкам:** Ошибочные измерения "сглаживаются" со временем
4. **Многодатчиковая интеграция:** Можно комбинировать данные от разных датчиков

### **Параметры настройки:**
- `p_occ`, `p_free`: вероятности занятости/свободы для модели датчика
- `resolution`: размер ячейки (компромисс между точностью и памятью)
- `clamping_min/max`: ограничение значений для предотвращения переполнения

**Пример в ROS:** Пакет `octomap` для 3D и `gmapping`/`cartographer` для 2D используют вариации этого подхода.

---

## **Задача: Посещение нескольких целевых точек (упрощенный TSP)**

### **Постановка задачи:**
Робот находится в стартовой точке S и должен посетить N целевых точек {T₁, T₂, ..., Tₙ}, после чего вернуться на базу B (может совпадать с S). Необходимо найти минимальный по длине/времени маршрут.

### **Формулировка как задачи на графе:**

**Граф G = (V, E, w):**
- **Вершины V:** {S, T₁, T₂, ..., Tₙ, B}
- **Ребра E:** Полносвязный граф между всеми вершинами
- **Вес w(u,v):** Стоимость перемещения между вершинами u и v
  - Может быть: евклидово расстояние, время пути, энергозатраты
  - Может учитывать препятствия (тогда вычисляется через планировщик пути)

**Цель:** Найти гамильтонов цикл минимального веса, начинающийся в S, проходящий через все Tᵢ, и заканчивающийся в B.

**Это классическая задача коммивояжера (TSP):**
```
minimize: Σ w(v_i, v_{i+1}) + w(v_k, S)
subject to: 
    - все Tᵢ посещены ровно один раз
    - начинается в S, заканчивается в B
```

### **Упрощенный эвристический подход:**

Поскольку точное решение TSP является NP-трудным, для роботов в реальном времени используют эвристики:

#### **Алгоритм 1: Ближайший сосед (Nearest Neighbor)**
```
1. Текущая позиция = S
2. Маршрут = [S]
3. Пока есть непосещенные целевые точки:
   4. Найти ближайшую непосещенную точку к текущей позиции
   5. Переместиться в эту точку
   6. Добавить ее в маршрут
   7. Отметить как посещенную
8. Вернуться в B
9. Вернуть маршрут
```
**Сложность:** O(N²)
**Недостаток:** Может давать неоптимальные решения из-за "жадности"

#### **Алгоритм 2: 2-opt локальная оптимизация (улучшение маршрута)**
```
1. Построить начальный маршрут (например, Nearest Neighbor)
2. Улучшать пока есть улучшения:
   3. Для каждой пары ребер (i,i+1) и (j,j+1):
       4. Если w(i,j) + w(i+1,j+1) < w(i,i+1) + w(j,j+1):
           5. Развернуть сегмент между i+1 и j
           6. Обновить маршрут
```
**Сложность:** O(N²) за итерацию

#### **Алгоритм 3: Кластеризация + локальный TSP (для большого N)**
```
1. Кластеризовать целевые точки на k кластеров (k-средних, DBSCAN)
2. Для каждого кластера:
   3. Решить TSP внутри кластера (точным методом, если мало точек)
   4. Найти "входную" и "выходную" точки кластера
3. Решить задачу посещения кластеров как TSP высшего уровня
4. Объединить маршруты
```

### **Практическая реализация для робота:**

```python
class RoboTSP:
    def __init__(self, start, goals, cost_matrix):
        self.start = start
        self.goals = goals
        self.cost = cost_matrix  # предвычисленная матрица стоимостей
        
    def nearest_neighbor_route(self):
        """Эвристика ближайшего соседа"""
        unvisited = set(self.goals)
        current = self.start
        route = [current]
        
        while unvisited:
            # Найти ближайшую цель
            nearest = min(unvisited, 
                         key=lambda g: self.cost[current][g])
            route.append(nearest)
            unvisited.remove(nearest)
            current = nearest
            
        # Вернуться на базу
        route.append(self.start)
        return route
    
    def compute_total_cost(self, route):
        """Вычислить стоимость маршрута"""
        total = 0
        for i in range(len(route)-1):
            total += self.cost[route[i]][route[i+1]]
        return total
```

### **Расширения для реалистичных сценариев:**

1. **Динамическое перепланирование:**
   - Если обнаруживается новое препятствие на пути
   - Если появляются новые целевые точки

2. **Учет временных окон:**
   - Некоторые точки должны быть посещены в определенное время
   - Формулировка как Vehicle Routing Problem with Time Windows (VRPTW)

3. **Мультиагентный случай:**
   - Несколько роботов посещают точки
   - Распределение целей между роботами + координация

4. **Интеграция с навигационным стеком:**
   - Матрица стоимостей вычисляется через планировщик пути
   - Учет ориентации робота (несимметричные затраты на повороты)

**Вывод:** Для реальных робототехнических систем используют комбинацию эвристик (ближайший сосед → 2-opt оптимизация) с возможностью динамического перепланирования. Точные методы применяют только для небольшого числа целей или оффлайн-планирования.

# Подробный разбор задачи: Посещение нескольких целевых точек (упрощенный TSP)

## **1. Полное понимание задачи**

**Исходная ситуация:**
- Есть **робот** с определенным местоположением
- Есть **стартовая точка S** (где робот находится сейчас)
- Есть **N целевых точек** {T₁, T₂, ..., Tₙ}, которые нужно посетить
- Есть **база B** (может быть та же точка, что и S)
- Цель: посетить ВСЕ точки и вернуться на базу

**Ограничения:**
- Каждую целевую точку нужно посетить **ровно один раз**
- Маршрут должен быть **циклическим** (заканчиваться там же, где начался, если B = S)
- Нужно минимизировать **общую стоимость** (длину, время, энергозатраты)

---

## **2. Почему это именно задача коммивояжера (TSP)?**

**Аналогия с классическим TSP:**
- **Коммивояжер** = робот
- **Города** = целевые точки T₁...Tₙ
- **Офис продавца** = стартовая точка S и база B
- **Расстояния между городами** = стоимость перемещения между точками

**Формальное соответствие:**
- **TSP:** Найти минимальный гамильтонов цикл в полном взвешенном графе
- **Наша задача:** Найти минимальный маршрут, проходящий через все вершины (S + Tᵢ + B)

---

## **3. Детальная формализация как задачи на графе**

### **3.1 Построение графа**

**Вершины V:**
```
V = {v₀, v₁, v₂, ..., vₙ, v_{n+1}}
где:
v₀ = S (старт)
v₁...vₙ = T₁...Tₙ (целевые точки)
v_{n+1} = B (база)
```
Всего: N+2 вершин

**Ребра E:**
- **Полносвязный граф:** Между каждой парой вершин существует ребро
- Ребро (u,v) существует для всех u,v ∈ V, u ≠ v

**Вес ребер w(u,v):**
- w(u,v) ≥ 0 (неотрицательная стоимость)
- Может быть:
  - w(u,v) = Евклидово расстояние в метрах
  - w(u,v) = Время перемещения в секундах
  - w(u,v) = Расход энергии в джоулях
- **ВАЖНО:** w(u,v) может быть ≠ w(v,u) если:
  - Робот поворачивается (разные затраты на повороты)
  - Есть односторонние препятствия
  - Разный рельеф (подъем vs спуск)

### **3.2 Математическая формулировка**

**Целевая функция (минимизация):**
```
minimize: ∑ w(xᵢ, xᵢ₊₁) + w(xₖ, x₀)
```
где:
- x₀, x₁, ..., xₖ — перестановка вершин
- k = N+1 (все вершины кроме последней в цикле)

**Ограничения:**
1. **Каждая вершина посещается ровно один раз:**
   ```
   ∑ xᵢⱼ = 1 для всех j (каждая вершина ровно один раз в маршруте)
   ∑ xᵢⱼ = 1 для всех i (из каждой вершины ровно одно исходящее ребро)
   ```
   где xᵢⱼ = 1, если ребро (i,j) входит в маршрут

2. **Исключение подциклов (subtour elimination):**
   ```
   uᵢ - uⱼ + (N+2)*xᵢⱼ ≤ N+1 для всех i,j ≥ 1, i ≠ j
   ```
   где uᵢ — вспомогательные переменные

3. **Начинается в S, заканчивается в B:**
   - Если S ≠ B: цепь от S до B через все Tᵢ
   - Если S = B: гамильтонов цикл

---

## **4. Разбор на конкретном примере**

### **Пример 1: Простой случай (4 целевые точки)**

**Дано:**
- S = (0,0)
- T₁ = (2,0), T₂ = (2,2), T₃ = (0,2), T₄ = (1,1)
- B = S = (0,0)
- Евклидовы расстояния

**Граф:**
- Вершины: {S, T₁, T₂, T₃, T₄} (5 вершин)
- Полносвязный (10 рёбер)
- Вес = расстояние

**Возможные маршруты:**
1. S → T₁ → T₂ → T₃ → T₄ → S
   Длина: 2 + 2 + 2 + √2 + √2 ≈ 8.83

2. S → T₄ → T₁ → T₂ → T₃ → S
   Длина: √2 + √2 + 2 + 2 + 2 ≈ 8.83

3. Оптимальный? S → T₁ → T₄ → T₂ → T₃ → S
   Длина: 2 + √2 + √2 + 2 + 2 ≈ 8.83

**Интересно:** В симметричном случае все маршруты равны!

### **Пример 2: Асимметричный случай (разные стоимости)**

**Таблица стоимостей:**
```
     S   T₁   T₂   T₃
S    0    5    8    6
T₁   4    0    7    5  
T₂   7    6    0    3
T₃   5    4    2    0
B=S
```

**Оптимальный маршрут:**
S → T₃ → T₂ → T₁ → S
Стоимость: 6 + 2 + 6 + 4 = 18

**Худший маршрут:**
S → T₂ → T₁ → T₃ → S
Стоимость: 8 + 6 + 5 + 5 = 24

---

## **5. Практические аспекты для робототехники**

### **5.1 Вычисление весов w(u,v)**

**Метод 1: Евклидово расстояние (простой, но неточный)**
```
w(u,v) = √((xᵥ-xᵤ)² + (yᵥ-yᵤ)²)
```
**Проблема:** Не учитывает препятствия!

**Метод 2: Длина пути от планировщика (точный, но медленный)**
```
1. Для каждой пары точек (u,v):
2. Запустить A* / Dijkstra на карте
3. w(u,v) = длина найденного пути
```
**Проблема:** O(N²) вызовов планировщика!

**Метод 3: Евклидово расстояние с эвристической поправкой**
```
w(u,v) = k * Евклидово_расстояние(u,v)
где k > 1 (например, 1.3) — коэффициент для учета обходов
```

### **5.2 Учет ориентации робота**

Если робот должен быть определенным образом ориентирован в точке:

**Расширение графа:**
- Каждая физическая точка представляется несколькими вершинами
- Например: T₁₀°, T₁₉₀°, T₁₂₇₀° (разные ориентации)
- w(T₁₀°, T₂₉₀°) включает стоимость поворота

### **5.3 Динамическое перепланирование**

**Сценарий:** Во время движения появляется новая целевая точка Tₙ₊₁

**Подходы:**
1. **Полное перепланирование:** Решить TSP заново
2. **Инкрементальное:** Вставить Tₙ₊₁ в текущий маршрут в лучшую позицию
3. **Локальное:** Посетить Tₙ₊₁ после текущей точки, затем продолжить исходный маршрут

---

## **6. Алгоритмы решения**

### **6.1 Точные методы (для N ≤ 15-20)**

**Алгоритм 1: Полный перебор (Brute Force)**
- Проверить все (N+1)! перестановок
- Сложность: O(N!) — непрактично при N > 10

**Алгоритм 2: Динамическое программирование (Хелд-Карп)**
```
dp[mask][i] = минимальная стоимость посещения множества mask, заканчивая в i
```
- Сложность: O(N² * 2^N)
- Работает для N до ~20

**Алгоритм 3: Целочисленное линейное программирование (ILP)**
- Формулировка как ILP задачи
- Решается солверами (Gurobi, CPLEX)
- Может решать до N = 50-100

### **6.2 Приближенные методы (для реальных роботов)**

**Алгоритм 4: Ближайший сосед (Nearest Neighbor)**
```python
def nearest_neighbor(start, points):
    current = start
    unvisited = set(points)
    route = [current]
    
    while unvisited:
        # Найти ближайшую
        nearest = min(unvisited, key=lambda p: cost(current, p))
        route.append(nearest)
        unvisited.remove(nearest)
        current = nearest
    
    # Вернуться на базу
    route.append(start)
    return route
```
- Сложность: O(N²)
- Гарантия: Не более O(log N) от оптимального

**Алгоритм 5: 2-opt локальная оптимизация**
```python
def two_opt_improve(route):
    improved = True
    while improved:
        improved = False
        for i in range(1, len(route)-2):
            for j in range(i+1, len(route)-1):
                # Текущие рёбра: (i-1,i) и (j,j+1)
                # Новые рёбра: (i-1,j) и (i,j+1)
                old_cost = cost(route[i-1], route[i]) + cost(route[j], route[j+1])
                new_cost = cost(route[i-1], route[j]) + cost(route[i], route[j+1])
                
                if new_cost < old_cost:
                    # Развернуть сегмент i...j
                    route[i:j+1] = reversed(route[i:j+1])
                    improved = True
```

**Алгоритм 6: Генетический алгоритм (для N > 20)**
- Популяция маршрутов
- Кроссовер, мутация, отбор
- Может найти хорошее решение за разумное время

---

## **7. Реализация для робота в ROS**

```python
#!/usr/bin/env python3
import rospy
from geometry_msgs.msg import PoseStamped
from nav_msgs.msg import Path
import numpy as np
from itertools import permutations

class TSPPlanner:
    def __init__(self):
        self.waypoints = []  # Список целевых точек
        self.start_pose = None
        self.base_pose = None
        
    def compute_distance_matrix(self):
        """Вычислить матрицу расстояний между всеми точками"""
        n = len(self.waypoints) + 2  # +2 для S и B
        dist_matrix = np.zeros((n, n))
        
        # Все точки: [start, waypoint1, ..., waypointN, base]
        all_points = [self.start_pose] + self.waypoints + [self.base_pose]
        
        for i in range(n):
            for j in range(n):
                if i != j:
                    # Евклидово расстояние (можно заменить на вызов планировщика)
                    dist_matrix[i][j] = self.euclidean_distance(
                        all_points[i], all_points[j])
        
        return dist_matrix
    
    def solve_tsp_nearest_neighbor(self, dist_matrix):
        """Решить TSP алгоритмом ближайшего соседа"""
        n = len(dist_matrix)
        visited = [False] * n
        route = [0]  # Начинаем с старта (индекс 0)
        visited[0] = True
        
        current = 0
        total_cost = 0
        
        # Посещаем все точки кроме базы (последняя вершина)
        for _ in range(n-2):
            # Найти ближайшую непосещенную вершину
            min_dist = float('inf')
            next_node = -1
            
            for j in range(n-1):  # Не включаем базу пока
                if not visited[j] and dist_matrix[current][j] < min_dist:
                    min_dist = dist_matrix[current][j]
                    next_node = j
            
            route.append(next_node)
            visited[next_node] = True
            total_cost += min_dist
            current = next_node
        
        # Возвращаемся на базу
        route.append(n-1)  # База - последняя вершина
        total_cost += dist_matrix[current][n-1]
        
        return route, total_cost
    
    def optimize_with_2opt(self, route, dist_matrix):
        """Применить 2-opt оптимизацию"""
        improved = True
        best_route = route[:]
        best_cost = self.calculate_route_cost(route, dist_matrix)
        
        while improved:
            improved = False
            for i in range(1, len(route)-2):
                for j in range(i+1, len(route)-1):
                    # Пробуем поменять рёбра
                    new_route = best_route[:]
                    new_route[i:j+1] = reversed(new_route[i:j+1])
                    new_cost = self.calculate_route_cost(new_route, dist_matrix)
                    
                    if new_cost < best_cost:
                        best_route = new_route
                        best_cost = new_cost
                        improved = True
                        break
                if improved:
                    break
        
        return best_route, best_cost
    
    def create_path_message(self, route_indices):
        """Создать ROS Path сообщение из маршрута"""
        path_msg = Path()
        path_msg.header.stamp = rospy.Time.now()
        path_msg.header.frame_id = "map"
        
        all_points = [self.start_pose] + self.waypoints + [self.base_pose]
        
        for idx in route_indices:
            pose_stamped = PoseStamped()
            pose_stamped.header = path_msg.header
            pose_stamped.pose = all_points[idx]
            path_msg.poses.append(pose_stamped)
        
        return path_msg

# Использование:
tsp_planner = TSPPlanner()
tsp_planner.start_pose = get_current_pose()
tsp_planner.waypoints = get_target_poses()
tsp_planner.base_pose = get_base_pose()

# 1. Вычислить матрицу расстояний
dist_matrix = tsp_planner.compute_distance_matrix()

# 2. Найти начальный маршрут
initial_route, initial_cost = tsp_planner.solve_tsp_nearest_neighbor(dist_matrix)

# 3. Оптимизировать
optimized_route, final_cost = tsp_planner.optimize_with_2opt(initial_route, dist_matrix)

# 4. Создать путь для исполнения
path_msg = tsp_planner.create_path_message(optimized_route)
```

---

## **8. Частные случаи и упрощения**

### **Случай 1: B = S (возврат в стартовую точку)**
- Классический симметричный TSP
- Можно использовать более эффективные алгоритмы

### **Случай 2: Линейный маршрут (B ≠ S, не нужно возвращаться)**
- Задача поиска гамильтонова пути минимального веса
- Можно преобразовать в TSP добавлением фиктивного ребра весом 0 между S и B

### **Случай 3: Приоритетные точки**
- Некоторые точки должны быть посещены раньше других
- Задача TSP с дополнительными ограничениями порядка

---

## **9. Оценка сложности для реального робота**

**Для N целевых точек:**
- **Вычисление матрицы стоимостей:** O(N²) вызовов планировщика
- **Решение TSP:** 
  - Точное: O(N²·2^N) — только для малых N
  - Эвристическое: O(N²) — для реального времени
- **Исполнение:** O(N) шагов навигации

**Практическое правило:**
- N ≤ 10: Точное решение (DP)
- 10 < N ≤ 50: Эвристика + 2-opt
- N > 50: Кластеризация + локальный TSP

---

## **Выводы**

1. **Задача посещения нескольких точек — это действительно TSP**, что делает ее вычислительно сложной для точного решения

2. **Для роботов используют эвристические подходы**, так как:
   - Нужно работать в реальном времени
   - Стоимости приблизительны (из-за динамической среды)
   - Можно перепланировать по мере движения

3. **Типовой пайплайн:**
   ```
   Сбор точек → Вычисление матрицы стоимостей → 
   Nearest Neighbor → 2-opt оптимизация → 
   Исполнение с мониторингом → Перепланирование при изменениях
   ```

4. **Ключевой компромисс:** Точность vs скорость. В робототехнике обычно выбирают быстрые эвристики с возможностью адаптации.